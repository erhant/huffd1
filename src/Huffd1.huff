/// @title Huffd1
/// @notice SPDX-License-Identifier: MIT
/// @author erhant <https://github.com/erhant>

///////////////////////////////////////////////////////////////////////////////
////                              INCLUDES                                 ////
///////////////////////////////////////////////////////////////////////////////
#include "./util/Owned.huff"
#include "./util/Polynomial.huff"

///////////////////////////////////////////////////////////////////////////////
////                                TABLE                                  ////
///////////////////////////////////////////////////////////////////////////////
#define table Basis {
    0x01050700020c000607
}
#define constant TOTAL_SUPPLY = 0x03
#define constant ORDER = 0x0d
#define constant COEFF_SIZE = 0x01

///////////////////////////////////////////////////////////////////////////////
////                             INTERFACES                                ////
///////////////////////////////////////////////////////////////////////////////
#define function name() nonpayable returns (string)
#define function symbol() nonpayable returns (string)
#define function ownerOf(uint256) view returns (address)
#define function balanceOf(address) view returns (uint256)
#define function transfer(address, uint256) nonpayable returns ()

///////////////////////////////////////////////////////////////////////////////
////                               STORAGE                                 ////
///////////////////////////////////////////////////////////////////////////////
#define constant BAL_SLOT = 0xbabe69babe69babe69babe69babe69 // balances
#define constant APV_SLOT = 0xface42face42face42face42face42 // approvals

///////////////////////////////////////////////////////////////////////////////
////                                MACROS                                 ////
///////////////////////////////////////////////////////////////////////////////
#define macro NAME() = takes (0) returns (0) {
    0x20 0x00 mstore // offset
    0x06 0x20 mstore // length (12 hex chars, 6 bytes)
    // encoded string "Huffd1"
    __RIGHTPAD(0x487566666431) 0x40 mstore
    0x60 0x00 return
}

#define macro SYMBOL() = takes (0) returns (0) {
    0x20 0x00 mstore // offset
    0x04 0x20 mstore // length (8 hex chars, 4 bytes)
    // encoded string "FFD1"
    __RIGHTPAD(0x46464431) 0x40 mstore
    0x60 0x00 return
}

#define macro OWNER_OF() = takes (1) returns (1) {
    // input:              [t] (tokenId)
    [BAL_SLOT]          // [t, s] (storageSlot)
    0x00                // [t, s, m] (memoryOffset)
    [TOTAL_SUPPLY]      // [t, s, m, l] (length)
    POLY_SLOAD()        // [t, m, l]
    dup3                // [t, m, l, t] (token id)
    POLY_EVAL(ORDER)    // [t, m, l, a] (address)
    swap3               // [a, m, l, t]
    pop pop pop         // [a]
    // output:             [a] (owner)
}

#define macro TRANSFER() = takes (3) returns (0) {
    // input:           // [t, b, a] (token, to, from)

    // assert that token is owner by caller
    dup3 OWNER_OF()     // [t, b, a, o] (owner of t)
    dup2 eq             // [t, b, a, a == o]
    success jumpi
    0x00 0x00 revert
    success:

    // find scale amount
    [ORDER] sub         // [t, b, -a] (-a = p - a) in field
    add                 // [t, v] (v := b - a)

    // load balance polynomial
    [BAL_SLOT]          // [t, v, s] (storageSlot)
    0x00                // [t, v, s, mP] (memoryOffset)
    [TOTAL_SUPPLY]      // [t, v, s, mP, l] (length)
    POLY_SLOAD()        // [t, v, mP, l]

    // load basis polynomial
    __tablestart(Basis) // [t, v, mP, l, c]
    dup5                // [t, v, mP, l, c, t]
    POLY_OFFSET(COEFF_SIZE, TOTAL_SUPPLY)
                        // [t, v, mP, l, c, o]
    add                 // [t, v, mP, l, c] (codeOffset)
    [COEFF_SIZE]        // [t, v, mP, l, c, s] (coefficient size)
    0xFFFF                // [t, v, mP, l, c, s, mQ] (memOffset)
    dup4                // [t, v, mP, l, c, s, mQ, l] (length)
    POLY_CODECOPY()     // [t, v, mP, l, mQ, l]
    pop swap1           // [t, v, mP, mQ, l]

    // scale basis polynomial with (b - a)
    dup4                // [t, v, mP, mQ, l, v]
    POLY_SCALE(ORDER)   // [t, v, mP, mQ, l]

    // add scaled basis polynomial to balance polynomial
    POLY_ADD(ORDER)     // [t, v, mP, l]

    // store the new polynomial
    [BAL_SLOT] swap1    // [t, v, mP, sQ, l]
    POLY_SSTORE()       // [t, v, sQ, l]
    pop pop pop pop     // []
}

#define macro BALANCE_OF() = takes (1) returns (1) {
    // input:           // [a] (address)

    // load balance polynomial once at the start
    [BAL_SLOT]          // [a, $] (storageSlot)
    0x00                // [a, $, m] (memoryOffset)
    [TOTAL_SUPPLY]      // [a, $, m, l] (length)
    POLY_SLOAD()        // [a, m, l]

    0x00                // [a, m, l, s] (total balance initially 0)
    swap1               // [a, m, s, l] 
    0x00                // [a, m, s, l, i] (index starts with 0)

    loop_begin:
    // [a, m, s, l, i]

        // loop condition
        dup2 dup2       // [a, m, s, l, i, l, i]
        lt iszero       // [a, m, s, l, i, i >= l]
        loop_end jumpi 

        // check ownership for token i
        dup4            // [a, m, s, l, i, m]
        dup3            // [a, m, s, l, i, m, l]
        dup3            // [a, m, s, l, i, m, l, i] (token id = index)
        POLY_EVAL(ORDER)// [a, m, s, l, i, m, l, o] (owner)
        
        // check if owner is the given address
        dup8            // [a, m, s, l, i, m, l, o, a]
        eq              // [a, m, s, l, i, m, l, eq] (eq := o == a)

        // add to total balance
        dup6            // [a, m, s, l, i, m, l, eq, s]
        add             // [a, m, s, l, i, m, l, s'] (s' := s + eq)
        swap5           // [a, m, s',l, i, m, l, s] 
        pop pop pop     // [a, m, s, l, i]

        // increment index
        0x01 add        // [a, m, s',l, i'] (i' := i + 1)

    // [a, m, s, l, i]
    loop_begin jump
    loop_end:

    pop                 // [a, m, s, l]
    pop                 // [a, m, s]
    swap1               // [s, a]
    pop                 // [s]
    // output:          // [s] (total balance)
}

///////////////////////////////////////////////////////////////////////////////
////                               MAIN                                    ////
///////////////////////////////////////////////////////////////////////////////
#define macro HUFFD1_CONSTRUCTOR() = takes (0) returns (0) {
    // the constant polynomial equal to OWNER will result
    // in all tokens being owned by that OWNER
    [OWNER]    sload    // [owner]
    [BAL_SLOT] sstore   // []
}

#define macro HUFFD1_MAIN() = takes (1) returns (1) {
    dup1 __FUNC_SIG(name)      eq name      jumpi
    dup1 __FUNC_SIG(symbol)    eq symbol    jumpi
    dup1 __FUNC_SIG(ownerOf)   eq ownerOf   jumpi
    dup1 __FUNC_SIG(transfer)  eq transfer  jumpi
    dup1 __FUNC_SIG(balanceOf) eq balanceOf jumpi
    no_match jump

    name:
        NAME()
    symbol:
        SYMBOL()
    ownerOf:
        0x04 calldataload   // [t] (tokenId)
        OWNER_OF()          // [a] (address)
        0x00 mstore         // []
        0x20 0x00 return    // []
    transfer:
        0x24 calldataload   // [t] (tokenId)
        0x04 calldataload   // [t, b] (to address)
        caller              // [t, b, a] (from address)
        TRANSFER()          // []
        0x00 0x00 return    // []
    balanceOf:
        0x04 calldataload   // [a] (address)
        BALANCE_OF()        // [s] (balance)
        0x00 mstore         // []   
        0x20 0x00 return    // []

    no_match:
}

///////////////////////////////////////////////////////////////////////////////
////                              WRAPPERS                                 ////
///////////////////////////////////////////////////////////////////////////////
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    OWNED_CONSTRUCTOR()
    HUFFD1_CONSTRUCTOR()
}

#define macro MAIN() = takes (0) returns (0) {
    0x00 calldataload 0xE0 shr
    OWNED_MAIN()
    HUFFD1_MAIN()
    0x00 0x00 revert
}
